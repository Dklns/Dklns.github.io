<!-- build time:Tue Sep 06 2022 00:43:22 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="未来前端架构师的小破站" href="http://dklns.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="未来前端架构师的小破站" href="http://dklns.github.io/atom.xml"><link rel="alternate" type="application/json" title="未来前端架构师的小破站" href="http://dklns.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://dklns.github.io/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/"><title>| Dklns's little unsightly site = 未来前端架构师的小破站</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="Created: 2022-09-05 15:36:44"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2022-09-05T15:36:44+08:00">2022-09-05</time> </span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">Symbols count in article</span> <span>5.4k</span> <span class="text">words</span> </span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">Reading time</span> <span>5 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Dklns's little unsightly site</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/c41fdb26cf08cb42.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/9273a13f1061ab07.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/Dklns/ImgHosting/Blog-PIC/wallhaven-y8zek7.png"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/Dklns/ImgHosting/Blog-PIC/wallhaven-g73593.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2022/09/05/135eddb103874249.jpg"></li><li class="item" data-background-image="https://cdn.jsdelivr.net/gh/Dklns/ImgHosting/Blog-PIC/wallhaven-6ovvz6.png"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="en"><link itemprop="mainEntityOfPage" href="http://dklns.github.io/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="D_klns"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="未来前端架构师的小破站"></span><div class="body md" itemprop="articleBody"><h1 id="处理器体系结构"><a class="anchor" href="#处理器体系结构">#</a> 处理器体系结构</h1><ul><li><p>由于 x86-64 指令系统过于复杂，为了方便学习和理解，CSAPP 参照 x86-64 的指令系统自定义了一个相对简单的指令系统 ——Y86-64</p><p>该指令系统包括定义各种</p><ul><li>状态单元</li><li>指令集以及它们的编码</li><li>编程规范</li><li>异常事件处理</li></ul></li></ul><p>以下笔记便是根据 CSAPP 所作的笔记</p><h2 id="指令系统结构"><a class="anchor" href="#指令系统结构">#</a> 指令系统结构</h2><p>指令系统是计算机软件和硬件交互的接口</p><p>程序员根据系统设计软件</p><p>处理器设计人员根据指令系统实现硬件</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled.png" alt="Untitled"></p><p>这是 Y86-64 定义的指令系统，定义了 15 个 64 位的程序寄存器，相对于 x86 少一个 % r15，还简化了条件码</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%201.png" alt="Untitled"></p><p>指令集的更改</p><p>传送数据指令，第一个字母代表源操作数，第二个字母代表目的操作数</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%202.png" alt="Untitled"></p><p>对指令进行编码</p><p>编码的第一个字节代表指令类型，分两个部分，每个部分占四比特，高四位表示指令代码，低四位表示指令功能</p><p>当指令还有寄存器类型操作数时，还会附加一个字节，这个字节被称为寄存器指示字节，它用来指定一个或两个寄存器</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%203.png" alt="Untitled"></p><p>因此还需要对寄存器进行编码，当操作数中没有寄存器类型操作数，应用 F，如立即数和内存地址</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%204.png" alt="Untitled"></p><p>整数操作指令，只能对寄存器数据进行操作，而下 x86 还允许对内存数据进行操作</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%205.png" alt="Untitled"></p><p>跳转指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%206.png" alt="Untitled"></p><p>条件传送指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%207.png" alt="Untitled"></p><p>停止指令（halt）可以使整个系统暂停运行</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%208.png" alt="Untitled"></p><h2 id="数字电路与处理器设计"><a class="anchor" href="#数字电路与处理器设计">#</a> 数字电路与处理器设计</h2><p>程序寄存器从本质上讲属于处理器内部的存储单元，通常我们讲寄存器的集合称为寄存器文件</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%209.png" alt="Untitled"></p><p>在处理器内部，寄存器文件和算术逻辑单元（ALU）是串联的</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2010.png" alt="Untitled"></p><p>这是一个寄存器文件的功能表述</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2011.png" alt="Untitled"></p><p>可以用硬件描述语言（HDL）对寄存器文件进行行为级建模，通常的硬件描述语言有两种，最常用的是 verilog，另外一种是 VHDL</p><h2 id="y86-64的顺序实现"><a class="anchor" href="#y86-64的顺序实现">#</a> Y86-64 的顺序实现</h2><p>实现所有的 Y86-64 指令所需要的计算可以被组织成六个基本阶段</p><p>即针对一条指令的执行过程</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2012.png" alt="Untitled"></p><ul><li><p>取指</p><p>取指阶段以程序计数器（PC）的值作为起始地址，取指操作每次从指令内存中读取 10 个字节，由于在取指操作之前无法判断当前指令的长度，Y86-64 的指令最长占 10 个字节，这样做就可以保证每次取指至少为一条完整的指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2013.png" alt="Untitled"></p><p>接下来将这 10 个字节分成两部分，一部分占 1 个字节，另一部分占 9 个字节，图中标号为 Split 的硬件单元处理第一部分，它将第一个字节分成两部分，每一部分占 4 个比特位</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2014.png" alt="Untitled"></p><p>根据 Y86-64 指令系统，这两个字段分别位指令代码和指令功能，这里用 icode 和 ifun 表示。</p><p>根据 icode 可以判断当前指令的状态信息，首先可以判断这条指令是否合法，如果 icode 在 0x0~0xB 之间，那么这条指令就是一条合法指令，此外根据 icode 还可以判断当前指令是否包含寄存器指示符字节以及是否包含常数字节，根据上述的判断结果就可以算出当前指令的长度。</p><p>这样下一条指令的地址可以通过 PC 中的值加上当前指令的长度计算出来</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2015.png" alt="Untitled"></p><p>继续看一下剩余 9 个字节是如何处理的</p><p>图中标号为 align 的硬件单元可以产生寄存器字段和常数字段，当 need——regids 等于 1 时，表示该指令包含寄存器指示符字节，那么第一个字节将被分成两部分，每一部分占 4 个比特位，然后分别装入寄存器 rA 和 rB 中</p><p>当 need_regids 等于 0 时，表示这条指令没有寄存器指示符字节，此时 rA、rB 这两个字段会被置为 oxF，当指令中只含有一个寄存器操作数时，同样另外一个字段也会被置为 0xF</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2016.png" alt="Untitled"></p><p>如果该指令含有常数，align 单元还会产生常数字段 valC，同样需要根据信号 need_regids 的值来判断，当 need_regids 等于 1 时，第 2 字节到第 9 个字节表示常数字段 valC</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2017.png" alt="Untitled"></p><p>当 need_regids 等于 0 时，第 1 个字节到第 8 个字节表示常数字段 valC</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2018.png" alt="Untitled"></p></li><li><p>译码</p><p>译码阶段是从寄存器文件中读取数据</p><p>在 Y86-64 处理器中寄存器文件有两个读端口，它支持同时进行两个读操作，两个读端口的地址输入为 srcA 和 srcB，从寄存器文件中读出的数值通过 valA 和 valB 输出，图中标号为 srcA 和 srcB 的圆角矩形块可以产生寄存器的 ID 值，产生寄存器的 ID 值需要指令代码 icode 以及寄存器指示值 rA 和 rB</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2019.png" alt="Untitled"></p><p>那为什么需要 icode 呢，如 push 指令，该指令的寄存器指示符中只含有目的寄存器的 ID 值，当执行压栈操作时，还需要获得栈顶指针 rsp 的值</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2020.png" alt="Untitled"></p><p>除此之外还有这些指令也是</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2021.png" alt="Untitled"></p></li><li><p>执行</p><p>执行阶段的核心部件时算术逻辑单元，简称 ALU。ALU 根据指令功能（ifun）来判断对输入的操作数进行何种运算，每次运行时，ALU 都会产生三个与条件码相关的信号 —— 零、符号、溢出</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2022.png" alt="Untitled"></p><p>不过，我们只希望 ALU 在执行算术逻辑指令时才会设置条件码，当 ALU 计算内存引用地址以及对栈进行操作时，并不会设置条件码，因此图中 Set_CC 会根据指令代码 icode 来控制是否要更新条件码寄存器</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2023.png" alt="Untitled"></p><p>标号为 cond 的硬件单元会根据指令功能和条件码寄存器产生一个 cnd 信号，对于跳转指令，如果 cnd 等于 1，执行跳转；如果 cnd 等于 0，则不执行跳转</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2024.png" alt="Untitled"></p><p>对于 ALU，不仅可以执行算术逻辑指令，还要涉及内存地址的计算以及栈指针的增加或减少的操作</p></li><li><p>访存</p><p>访存阶段的任务就是从内存中读取数据或者将数据写入内存中，图中的读控制块（Memory read）表明应该进行读操作，写控制块表明应该进行写操作</p><p>此外还有产生内存地址和输入数据的控制块</p><p>访存阶段的最后操作会根据图中的信号来计算状态码 Stat</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2025.png" alt="Untitled"></p></li><li><p>写回</p><p>写回阶段是将数据写入到寄存器文件，两个写端口分别为 M 和 E，对应得地址输入为 dstE 和 dstM</p><p>需要注意的是，当执行条件传送指令（cmov）时，写入操作还要根据执行阶段计算出的 cnd 信号，当不满足条件时可以将目的寄存器设置为 0xF 来禁止写入寄存器文件</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2026.png" alt="Untitled"></p></li><li><p>更新 PC</p><p>PC 的值可能有三种情况</p><ul><li>如果当前正在执行的指令是函数调用指令 Call，那么新的 PC 就等于 call 指令的常数字段</li><li>如果当前正在执行的指令是函数返回指令 ret，指令 ret 在访存阶段会从内存（栈）中读出返回地址，这个返回地址就是新的 PC 值</li><li>如果当前正在执行的指令是跳转指令（jxx），当 cnd 信号等于 1 时，也就是满足跳转条件时，此时新的 PC 值等于跳转指令的常数字段，当不满足条件时，新的 PC 等于当前 PC 的值加上当前指令的长度</li></ul></li></ul><h2 id="流水线"><a class="anchor" href="#流水线">#</a> 流水线</h2><h3 id="流水线的通用属性和原理"><a class="anchor" href="#流水线的通用属性和原理">#</a> 流水线的通用属性和原理</h3><p>在现代逻辑电路的设计中，电路的延迟用皮秒来表示</p><p>这是一个未流水化的硬件设计</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2027.png" alt="Untitled"></p><p>假设信号经过组合逻辑耗时 300ps，输出信号加载到时钟寄存器保存需要 20ps</p><p>那么整个过程耗时 320ps</p><p>可以将这个过程抽象为指令的执行</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2028.png" alt="Untitled"></p><p>假设三条指令通过上述逻辑单元，可以得到一个流水线图</p><p>时间从左到右流逝</p><p>这就是执行下一条指令时必须等待上一条指令执行完</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2029.png" alt="Untitled"></p><ul><li><p>吞吐量</p><p>每秒执行的指令数</p><p>假设执行一条指令需要 320ps</p><p>那么这个系统 1s 大约可以执行 3.12 乘以 10 的 9 次方条指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2030.png" alt="Untitled"></p><p>我们将吞吐量的单位定义为每秒千兆条指令（GIPS），也就是每秒十亿条指令</p><p>因此该系统的最大吞吐量约为 3.12CGIPS</p></li><li><p>时钟寄存器</p><p>在电路设计中，时钟寄存器直接将它的输入和输出连接到电路中，大多数情况下寄存器都保持在稳定状态</p><p>假设图中寄存器的状态是 x，那么它的输出也是 x，当寄存器的输入端产生了一个新的输入 y 时，如果时钟信号为低电位，那么寄存器的状态不会立即发生改变，当时钟信号由低电平变成高电平时，输入信号 y 才会加载到寄存器</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2031.png" alt="Untitled"></p></li></ul><p>理想化的流水化的系统</p><p>假设将图中的组合逻辑单元执行的操作分成三个阶段，在各阶段间插入寄存器，耗时如图所示，每条指令的执行都会经过这三个阶段</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2032.png" alt="Untitled"></p><p>我们将时钟周期设置为 120ps，那么指令从开始到结束需要三个完整的时钟周期</p><ul><li><p>如何理解时钟周期</p><p>每过一个时钟周期，即电平上升，这时寄存器输入段的状态才会进入寄存器，而寄存器的输出段与寄存器状态相同</p></li></ul><p>以下是这样流水化的系统的流水线图</p><p>只要指令 1 从阶段 A 进入阶段 B 之后，就可以让指令 2 进入阶段 A，以此类推，在 A 执行完后，之后系统每隔 120s 就有有一条指令离开，一条新的指令进入</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2033.png" alt="Untitled"></p><p>逐步分析一下时钟上升之前，流水线的状态</p><p>这是刚开始时</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2034.png" alt="Untitled"></p><p>这是 239ps 时</p><p>指令 1 已经从阶段 A 到阶段 B，青色表示，状态在第二个寄存器的输入端</p><p>指令 2 经过阶段 A 的计算结果已经到达第一个寄存器的输入，黄色表示</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2035.png" alt="Untitled"></p><p>当时钟上升时，如图所示</p><p>此时指令 3 已经进入阶段 A 的输入，蓝色表示</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2036.png" alt="Untitled"></p><p>359ps 时</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2037.png" alt="Untitled"></p><p>时钟上升</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2038.png" alt="Untitled"></p><p>现实情况中，各个阶段的延迟可能都是不等的</p><p>时钟的速率受最慢阶段的影响</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2039.png" alt="Untitled"></p><p>当我们把计算过程分成更多的阶段时，系统的吞吐量也提升了</p><p>虽然增加流水线的阶段数可以提升系统的吞吐量，但是过深的流水线同样也会导致性能的下降</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2040.png" alt="Untitled"></p><h3 id="流水线的硬件结构"><a class="anchor" href="#流水线的硬件结构">#</a> 流水线的硬件结构</h3><ul><li>结构图中每个模块代表的含义</li></ul><p>对于 Y86-64 的顺序实现，更新 PC 是发生在最后一个阶段，也就是说要等到一条指令执行完前面所有阶段，才能更新 PC 进行新的取指执行下一条指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2041.png" alt="Untitled"></p><p>为了实现流水化，即每个周期要结束的时候更新 PC，那么每执行一个阶段就都可以进行取指，即让新的指令进入系统</p><p>具体的实现是，创建一个寄存器来保存指令在执行过程中产生的信号，每次写回阶段的信息给寄存器，取指根据信息取指，形成轮回</p><p>其他的硬件单元的控制模块都没有发生改变，我们将这种改进方法称为电路重定时</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2042.png" alt="Untitled"></p><p>将顺序结构改造成流水结构</p><p>宏观来看其实很简单，就是在各阶段间插入一个寄存器</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2043.png" alt="Untitled"></p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2044.png" alt="Untitled"></p><p>五级流水线结构</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2045.png" alt="Untitled"></p><ul><li><p>每个寄存器保存前面阶段计算结果的意义</p><p>流水执行指令的过程中，每个阶段其实都在计算不同的指令，而流水是一直在执行的，不是等一个指令执行完，而是分阶段，那么每个阶段的计算结果下一个阶段可能要用，对于一条指令，每个阶段都要用上一个阶段计算结果，但每个阶段又是在计算不同的指令，那么就必须要有一个东西来保存每条指令的计算结果状态，那不可能有多少条指令就给多少个这样的容器吧</p><p>而图中的在每个阶段间插入一个寄存器的方式，就保证了每个阶段计算一条指令在该阶段的结果时，它前面的寄存器提供的一定是这条指令在上个阶段的计算结果</p><p>还有一个功能就是，寄存器还保存了状态码，也就是说一旦发现有异常，就可以执行异常处理</p><p>假如没有这个寄存器，那么就要等到产生异常的指令在访存阶段的时候才会触发异常处理，而在这之前已经取指了两条指令了，而这取指的两条指令很可能是错误的</p></li></ul><h3 id="数据冒险"><a class="anchor" href="#数据冒险">#</a> 数据冒险</h3><ul><li><p>阶段名缩写</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2046.png" alt="Untitled"></p></li><li><p>数据相关</p><p>执行下一条指令需要上一条指令的结果</p><p>如图</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2047.png" alt="Untitled"></p></li></ul><p>对于如下指令的执行，</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2048.png" alt="Untitled"></p><p>在第四周期，addq 处于译码阶段需要读取寄存器 rax 和 rdx 的值，而此时前两条指令分别处于访存阶段和执行阶段</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2049.png" alt="Untitled"></p><p>这就是由于数据相关导致的流水线产生错误的计算结果，我们将这种情况称为冒险，或冲突</p><p>冒险分为两类，数据冒险，控制冒险</p><p>暂停</p><p>暂停的实现需要判断何时暂停，暂停多久</p><p>判断暂停的方法是指令在译码阶段读取寄存器时，通过将读取寄存器的 ID 值分别与执行阶段、访存阶段以及写回阶段所执行指令的目的寄存器进行对比，如果存在寄存器 ID 相等的情况，那么就说明存在数据相关，该指令就需要在译码阶段等待</p><p>对于流水线的执行阶段，原本是要正常执行的指令，暂停之后通过插入气泡来代替暂停的指令，气泡不会改变寄存器、内存、条件码以及程序状态</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2050.png" alt="Untitled"></p><p>虽然使用暂停技术可以解决数据冒险，但是基于这种机制实现的流水线性能并不高，这是因为程序中数据相关的情况非常的多，频繁暂停指令的执行会严重降低流水线的吞吐量</p><p>因为指令 irmovq 在访存阶段没有进行任何操作，那么可以将计算结果直接传给 addq 指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2051.png" alt="Untitled"></p><p>具体实现（由于篇幅限制，去掉了取指阶段）</p><p>添加一条信号线，将指令 irmovq 经过 ALU 的执行结果直接传送到指令 addq 的译码阶段，我们将这种实现技术称为数据转发，也称旁路</p><p>数据转发的实现需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2052.png" alt="Untitled"></p><p>通过添加的旁路路径能够转发前面指令的结果，这使得流水线可以不暂停就能处理大多数情况的数据冒险，</p><p>但是有一种类型的数据冒险不能单纯的使用数据转发来解决</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2053.png" alt="Untitled"></p><p>mrmovq 需要读取内存，而访存发生在流水线的后期，即访存时，addq 指令已经在执行阶段了，而转发数据也无法将指送回到过去的时间</p><p>所以为了解决这一类冒险，需要将暂停和数据转发结合，</p><p>即 addq 暂停一个周期</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2054.png" alt="Untitled"></p><h3 id="控制冒险"><a class="anchor" href="#控制冒险">#</a> 控制冒险</h3><p>控制冒险出现的原因</p><p>在流水线的设计中，我们期望每个时钟周期都能完成一条指令的执行，想要达到这个目的，流水线在每一个时钟周期都要取到一条指令，因此每一次取指操作后，必须马上确定下一条指令的地址</p><p>对于 Y86-64 指令系统大部分的指令都能满足这个要求，但是 如果取出的指令是返回指令 ret 时，下一条指令的地址需要从栈中读出，因此必须要等到访存操作结束之后才能确定下一条指令的地址</p><p>除此之外还有一种情况就是取到的指令是分支条件指令时，流水线无法立即判断是否要进行跳转操作，需要经过执行阶段后，才能确定是否进行跳转</p><p>当取指阶段取到了返回指令 ret 和条件分支指令时，流水线无法立即得知下一条指令的地址，这就是控制冒险</p><ul><li><p>对于 ret</p><p>对于以下指令</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2055.png" alt="Untitled"></p><p>调整一下指令的执行顺序</p><p>第三个周期时，返回指令 ret 开始进入流水线执行，</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2056.png" alt="Untitled"></p><p>避免控制冒险的方法是，当 ret 指令处于取指，译码，执行三个阶段时，流水线不能进行其他有用的操作，只能在流水线中插入三个气泡，知道第七个周期时，ret 指令到达写回阶段，</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2057.png" alt="Untitled"></p></li><li><p>对于条件分支指令</p><p>其结果无非是跳转和不跳转，</p><p>为方便描述，CSAPP 采用的策略是预测分支总是跳转，实际分支预测的策略要复杂的多</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2058.png" alt="Untitled"></p><p>流水图如下</p><p>在第四个周期时，跳转分支指令进入了执行阶段，结果是分支预测发生了错误</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2059.png" alt="Untitled"></p><p>因此这两条指令不应该出现在流水线中，应该立即终止，幸运的是这两条指令还没有进入执行阶段，并不会影响程序的正确性，所以只需要简单的剔除就行了</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2060.png" alt="Untitled"></p><p>在第一条指令的执行阶段插入气泡，在第二条指令的译码阶段插入气泡</p><p><img data-src="%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/Untitled%2061.png" alt="Untitled"></p></li><li><p>暂停</p></li><li><p>插入气泡</p></li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2022-09-05 23:37:48" itemprop="dateModified" datetime="2022-09-05T23:37:48+08:00">2022-09-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="D_klns WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="D_klns Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="D_klns PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>D_klns <i class="ic i-at"><em>@</em></i>未来前端架构师的小破站</li><li class="link"><strong>Post link: </strong><a href="http://dklns.github.io/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%207b8e8222e66f4648a08bf1e9c3e34b9c/">http://dklns.github.io/CSAPP/CSAPP a28e0f2f78644379af950ba4fb61862f/处理器体系结构 7b8e8222e66f4648a08bf1e9c3e34b9c/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%20c9b6fc92d890447aa8b475e77bdd8afe/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Dklns&#x2F;ImgHosting&#x2F;Blog-PIC&#x2F;wallhaven-9mjoy1.png" title="Untitled"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>Untitled</h3></a></div><div class="item right"><a href="/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%209fe37eb5b6c144f6b0e4f51af62bf92b/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;Dklns&#x2F;ImgHosting&#x2F;Blog-PIC&#x2F;005WWep7gy1fx7zt7je6fj31hc0u04qp.jpg" title="Untitled"><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i></span><h3>Untitled</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">处理器体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">指令系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">数字电路与处理器设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#y86-64%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">Y86-64 的顺序实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.4.</span> <span class="toc-text">流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">流水线的通用属性和原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">流水线的硬件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9"><span class="toc-number">1.4.3.</span> <span class="toc-text">数据冒险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">1.4.4.</span> <span class="toc-text">控制冒险</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="D_klns" data-src="/images/avatar.jpg"><p class="name" itemprop="name">D_klns</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">74</span> <span class="name">posts</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3lvdXJuYW1l" title="https:&#x2F;&#x2F;github.com&#x2F;yourname"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>About</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%20c9b6fc92d890447aa8b475e77bdd8afe/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%209fe37eb5b6c144f6b0e4f51af62bf92b/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/CSAPP/CSAPP%20a28e0f2f78644379af950ba4fb61862f/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%209fe37eb5b6c144f6b0e4f51af62bf92b/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/web/web%20974f619e31ed44fba656fabc29805684/node%20js%204c54c0f111384f97ba0390d63bea76a7/%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%20ae0f75e65699434a80d944bf446b04cc/nrm%20f65c6b8a3a6145109f188dcceda91f47/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/JAVA/JAVA%2041e0d7bd51224be1a2d0dcaeefaee9b9/%E6%96%87%E4%BB%B6%2081c41e70d4044f158efccfd14d532fa5/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/JAVA/JAVA%2041e0d7bd51224be1a2d0dcaeefaee9b9/%E4%BB%A3%E7%A0%81%E5%9D%97%20fcade0e498dc42d08b55eb724daa61df/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/JAVA/JAVA%2041e0d7bd51224be1a2d0dcaeefaee9b9/Map%201771113d3e6a4bcfb08e0e00db787e9e/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/assembly/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20f4038f5812c2418f84ce7c07b4065f3e/%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%88%B6%E8%A1%A8%20c70533ac98954d70b86052d7507c2f1e/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/web/web%20974f619e31ed44fba656fabc29805684/node%20js%204c54c0f111384f97ba0390d63bea76a7/%E6%A8%A1%E5%9D%97%E5%8C%96%204bb34f1a834247e28447d6e7f30ccd53/npm%E4%B8%8E%E5%8C%85%209034611302c64fc0b393f4bb4a19bc7e/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/web/web%20974f619e31ed44fba656fabc29805684/HTML%20cba22772532641e7b9d5a7dfcbbefe4c/" title="HTML">HTML</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/assembly/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20f4038f5812c2418f84ce7c07b4065f3e/int%E6%8C%87%E4%BB%A4%2068af561e18434b7c8aa54c9f33c5eaa9/" title="Untitled">Untitled</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/web/web%20974f619e31ed44fba656fabc29805684/%E5%AE%9E%E8%B7%B5%204620b5f17bde47b9843d8c254dbae67c/%E6%89%A9%E5%B1%95%E5%8D%A1%E7%89%87%20c0ee2e01382d415b96f17e5d42b41449/" title="Untitled">Untitled</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">D_klns @ Dklns's little unsightly site</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="Symbols count total">87k words</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="Reading time total">1:19</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"CSAPP/CSAPP a28e0f2f78644379af950ba4fb61862f/处理器体系结构 7b8e8222e66f4648a08bf1e9c3e34b9c/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->