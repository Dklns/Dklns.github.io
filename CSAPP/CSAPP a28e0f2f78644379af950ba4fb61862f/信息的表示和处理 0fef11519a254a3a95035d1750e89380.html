<h1 id="信息的表示和处理"><a class="anchor" href="#信息的表示和处理">#</a> 信息的表示和处理</h1>
<h2 id="信息的储存"><a class="anchor" href="#信息的储存">#</a> 信息的储存</h2>
<h3 id="byte字节"><a class="anchor" href="#byte字节">#</a> byte（字节）</h3>
<p><strong>最小的可寻址的单位</strong></p>
<p>由八个位（bit）组成・</p>
<p>十进制转换为十六进制</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924065-4f48dbc9-fdee-442e-b0b5-4fe8f81a77be.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924065-4f48dbc9-fdee-442e-b0b5-4fe8f81a77be.png" /></p>
<p>十进制转换为二进制也是如此</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924156-483122e1-06a7-4069-a4d5-e5de0de45f46.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924156-483122e1-06a7-4069-a4d5-e5de0de45f46.png" /></p>
<h3 id="字长"><a class="anchor" href="#字长">#</a> 字长</h3>
<p>字长是 CPU 的主要技术指标之一，指的是 CPU 一次能并行处理的二进制位数，字长总是 8 的整数倍，通常 PC 机的字长为 16 位（早期），32 位，64 位。 PC 机可以通过编程的方法来处理任意大小的数字，但数字越大，PC 机就要花越长的时间来计算。 PC 机在一次操作中能处理的最大数字是由 PC 机的字长确定的。</p>
<p>简单的说，<strong>w 位的机器，其字长就是 w 位</strong></p>
<p>32 位的机器的命令可以在 64 位的机器上运行，反之不行</p>
<p>不同数据类型的占字节大小</p>
<h3 id="寻址和字节顺序"><a class="anchor" href="#寻址和字节顺序">#</a> 寻址和字节顺序</h3>
<p>在几乎所有的机器上，多字节对象都被储存在连续的字节序列内，而上面说过了字节就是最小的寻址单位</p>
<p>所以每个字节都会一个地址，如 0x101</p>
<p>对象的地址为所使用字节中最小的地址，int 型的数占 4 个字节，如果一个 int 的地址为 0x101，则它被储存在 0x101，0x102，0x103,0x104 位置中</p>
<p>如一个整型，0x01234567, 现在我们知道了，现在我们知道了它的储存地址规则，但是排列一个对象的字节有两个规则</p>
<p>大端法：</p>
<p>最高有效字节储存在前边</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924246-a4d553fa-2fc3-4d77-9337-1ddf8cb943f7.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924246-a4d553fa-2fc3-4d77-9337-1ddf8cb943f7.png" /></p>
<p>小端法</p>
<p>与大端法相反</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924328-c8356498-4790-4163-9049-f05ca76b2805.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924328-c8356498-4790-4163-9049-f05ca76b2805.png" /></p>
<h3 id="布尔代数"><a class="anchor" href="#布尔代数">#</a> 布尔代数</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924408-2e5e5b82-c21c-4b00-9719-e14ccf3a35c5.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924408-2e5e5b82-c21c-4b00-9719-e14ccf3a35c5.png" /></p>
<p>掩码运算</p>
<p>想要获得对象的最低有效字节</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924492-1acc6e86-002e-4dfd-a0a2-5b47a77c14a5.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924492-1acc6e86-002e-4dfd-a0a2-5b47a77c14a5.png" /></p>
<h3 id="位级运算"><a class="anchor" href="#位级运算">#</a> 位级运算</h3>
<p>~ 取反</p>
<p>&amp; 与</p>
<p>| 或</p>
<h3 id="逻辑运算"><a class="anchor" href="#逻辑运算">#</a> 逻辑运算</h3>
<p>&amp;&amp; 与</p>
<p>|| 或</p>
<p>！非</p>
<p>需要注意的是，逻辑运算认为所有非零数都是 true，0 为 false</p>
<p>C 语言中逻辑运算只返回 1 或 0</p>
<p>逻辑运算中前一个对象为非，则不会再考虑后一个对象</p>
<h3 id="移位运算"><a class="anchor" href="#移位运算">#</a> 移位运算</h3>
<p>左移，简而言之，将所有为向左移动，移出界限的位丢弃，并在右端补上 0</p>
<p>右移</p>
<p>逻辑右移，与左移相似，方向不同</p>
<p>算数右移，当对象的最高有效位为 0 时与右移一样，为 1 时向右移动时，左端补 1</p>
<h2 id="整数的表示"><a class="anchor" href="#整数的表示">#</a> 整数的表示</h2>
<h3 id="有符号数"><a class="anchor" href="#有符号数">#</a> 有符号数</h3>
<p>有 w 位的数的范围是 - 2^(w-1)  ~ 2^(w-1) - 1</p>
<p>首先为什么正数会比负数少一个，这很简单，因为还有 0 这个数字，也就是说负数与非负数的数量是相同的</p>
<p>其次为什么最高位是 2^(w-1)，因为无符号数的二进制用<strong>补码编码</strong>表示，最高有效位为符号位，1 时为负，0 时为正</p>
<p>但这也只是针对最高位而言，最高位为 1 时，我们都知道二进制怎么换算成十进制，就是位上数乘以 2 的该位数减一次方，所以<strong>负数就是最高位的 1 是负一，而其他位的 1 都是正一</strong>，至于换算没有任何变化</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924571-f99779f4-46e9-44a0-a339-ae2adbd85f01.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924571-f99779f4-46e9-44a0-a339-ae2adbd85f01.png" /></p>
<p>如 1110 = -1 x 2^3 + 2^2 + 2^1 + 2^0  = -2 而 0111 = 0  x 2^3 + 2^2 + 2^1 + 2^0 = 7</p>
<p>也就是说 w 位的数它的最高位被用来表示正负了，那么正数的最大值是多少呢，也就是剩下的 w-1 位全部多是 1，也就是 2^w - 1</p>
<h3 id="无符号数"><a class="anchor" href="#无符号数">#</a> 无符号数</h3>
<p>有符号数就很好理解了，就是二进制表示时位上数乘以对应权重最后相加</p>
<p>所以 w 位的数字类型的范围是 2^w - 1，缺的一个数是 0</p>
<h3 id="有符号数与无符号数相互转化"><a class="anchor" href="#有符号数与无符号数相互转化">#</a> 有符号数与无符号数相互转化</h3>
<p>对于 C 语言，两种类型数转化时，位模式不变，只是解释位模式的方式变了</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924647-c0e52ab9-45ef-4e7c-a923-9497ffe8fbc7.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924647-c0e52ab9-45ef-4e7c-a923-9497ffe8fbc7.png" /></p>
<p>转化公式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924748-323d403c-3ee6-4eb0-8a5f-256711bcb0be.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924748-323d403c-3ee6-4eb0-8a5f-256711bcb0be.png" /></p>
<p><strong>在 C 语言中一个无符号数与一个有符号数进行运算时，会将有符号数转化为无符号数</strong></p>
<h2 id="数位扩展"><a class="anchor" href="#数位扩展">#</a> 数位扩展</h2>
<h3 id="小转大"><a class="anchor" href="#小转大">#</a> 小转大</h3>
<p>对于无符号数，就对扩展的数位补 0 就行了</p>
<p>对于有符号数，如果符号位表示正数就补 0，反之补 1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924853-6bf3d01a-cf57-4492-bc88-90b4253a8c3b.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924853-6bf3d01a-cf57-4492-bc88-90b4253a8c3b.png" /></p>
<p>那么为什么对于有符号数符号位表示负数时扩展位补 1 能保持数值不变呢</p>
<p>这样理解，假如 4 位的数，1011，即 - 1 x 2^3 + 2^1 + 2^0 = -5 那么扩展一位后就成了 11011 , (-1 x 2^4 + 2^3) + 2^1 + 2^0 = -5，括号内的数依然是 -1 x 2^3 ，因为每扩展一位时符号位前移一位，本来的表示负数的位就正数了，即 w 位为正，w+1 位为负，而 w+1 位的数值的绝对值就是 w 位数值绝对值的二倍，那么其实<strong> w+1 数值位加上 w 位数值依然为未扩展时 w 位的数值</strong>，简而言之就是 - 2+1= -1，以此类推，无论扩展多少位都补 1，这些位的数值相加再加上最早的符号位的数值的绝对值，其结果都是原来的符号位的数值</p>
<h3 id="大转小"><a class="anchor" href="#大转小">#</a> 大转小</h3>
<p>用无符号数的截断解释来解释</p>
<p>一个 32 位被截断 16 位，就相当于 x % 216，因为是二进制，大于等于 16 位的位上数值取模 216 都等于 0，而小于 216 的位上数值取模 216 数值不变</p>
<h2 id="整数的运算"><a class="anchor" href="#整数的运算">#</a> 整数的运算</h2>
<h3 id="加"><a class="anchor" href="#加">#</a> 加</h3>
<h3 id="无符号"><a class="anchor" href="#无符号">#</a> 无符号</h3>
<p>定义一个运算，w 为 w 位，u 代表无符号，加号就是加法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924954-a1355881-105b-464a-8080-e6a148a6d26f.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336924954-a1355881-105b-464a-8080-e6a148a6d26f.png" /></p>
<p>对于 w 位的无符号数，x+y 大于 2^w 就会溢出</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925053-dc3ff736-080d-49f0-8619-e6d573a335e8.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925053-dc3ff736-080d-49f0-8619-e6d573a335e8.png" /></p>
<p>原因</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925140-cb432fb3-86eb-4281-b067-41d1706af192.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925140-cb432fb3-86eb-4281-b067-41d1706af192.png" /></p>
<p>为了保持原来的位，最高位会被去除，也就相当于减去 2^w</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925218-489cb5d7-e159-44ac-a042-209e24a66abd.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925218-489cb5d7-e159-44ac-a042-209e24a66abd.png" /></p>
<p>C 语言中判断无符号数相加是否溢出</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925293-c4004fcb-50f7-429e-96c9-44f0b95a4f56.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925293-c4004fcb-50f7-429e-96c9-44f0b95a4f56.png" /></p>
<p>发生溢出时，得到的和小于相加的任意一个数</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925393-ddc68fc1-6fcb-4f46-95b4-26c82f8384ae.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925393-ddc68fc1-6fcb-4f46-95b4-26c82f8384ae.png" /></p>
<h3 id="有符号"><a class="anchor" href="#有符号">#</a> 有符号</h3>
<p>分为正溢出和负溢出</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925506-7c42da18-c364-4792-a053-9b1822e221e2.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925506-7c42da18-c364-4792-a053-9b1822e221e2.png" /></p>
<h3 id="逆元"><a class="anchor" href="#逆元">#</a> 逆元</h3>
<p>x + x' = 0 x' 就是 x 的逆元</p>
<p>对于只有正数的无符号数，怎么会有相反数呢，逆元是相加为零的数，不一定是负数</p>
<p>当 x + y = 2^w 时由于溢出，丢弃最高位后得到的就是 0，所以 x' = 2^w - x</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925667-0dd517e6-08a9-4cf9-b121-54d99d525e6a.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925667-0dd517e6-08a9-4cf9-b121-54d99d525e6a.png" /></p>
<p>对于有符号数来说，只要大于最小值，其逆元都是相反数，而最小值的逆元是本身，因为补码表示最小值与最大值不对称，所以最小值的逆元只能通过溢出算得，</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925772-0cc28de4-232f-4bba-9075-a00adcd12354.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925772-0cc28de4-232f-4bba-9075-a00adcd12354.png" /></p>
<h3 id="乘法"><a class="anchor" href="#乘法">#</a> 乘法</h3>
<p>截断操作对应的数学运算 —— 取模</p>
<p>w 位的数相乘，结果可能需要 2w 位的数表示，所以需要截断 w 位，即取模 2^w</p>
<p>无符号数相乘后结果的位级与有符号数相乘后的位级不同，但是截断后的位级却是相同的</p>
<p>以下是例子</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925870-cb4efcc9-00a0-4357-9c74-c04be8d60ac7.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925870-cb4efcc9-00a0-4357-9c74-c04be8d60ac7.png" /></p>
<p>数学解释</p>
<p>对于相同二进制表示的无符号数和有符号数的关系如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925968-f190c545-a31a-464b-b26e-5dfad5e7fb75.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336925968-f190c545-a31a-464b-b26e-5dfad5e7fb75.png" /></p>
<p>原因</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926051-cb875c60-b2c3-40f2-beef-91751ff41730.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926051-cb875c60-b2c3-40f2-beef-91751ff41730.png" /></p>
<p>因为 x 一撇和 x，以及 y 一撇和 y 的位级表示相同，所以得结论 <strong>无符号数相乘后结果的位级与有符号数相乘后的位级不同，但是截断后的位级却是相同的</strong></p>
<h3 id="乘以常数"><a class="anchor" href="#乘以常数">#</a> 乘以常数</h3>
<p>由于乘法指令的执行需要多个时钟周期，所以许多 C 语言的编译器采用位移和加减法操作实现乘法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926196-5cd06498-654d-4588-963f-43489f8bb85d.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926196-5cd06498-654d-4588-963f-43489f8bb85d.png" /></p>
<p>为什么乘以 2 的幂可以转为左移操作</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926296-589afe00-8e13-4f11-9d2e-6d7bceeb4fc4.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926296-589afe00-8e13-4f11-9d2e-6d7bceeb4fc4.png" /></p>
<p>左移在右边补 0，所以左移 k 位就相当与之前的每一位乘 2^k</p>
<p>乘以任意常数</p>
<p>把常数拆分成 2 的幂的加减形式，就可以将乘转为移位和加减法了</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926394-87bb3b4f-1ede-41f3-8c1a-0c9df724f049.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926394-87bb3b4f-1ede-41f3-8c1a-0c9df724f049.png" /></p>
<h3 id="除法的右移"><a class="anchor" href="#除法的右移">#</a> 除法的右移</h3>
<p>无符号数采用的是逻辑右移，有符号数采用的是算术右移</p>
<p>整数除法遇到除不尽时，其商会往 0 的方向舍入</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926479-bb9cb541-390a-4ffb-a8b2-fa651fe09aba.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926479-bb9cb541-390a-4ffb-a8b2-fa651fe09aba.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926564-ffbf154f-7ac1-4490-b9af-036899c53425.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926564-ffbf154f-7ac1-4490-b9af-036899c53425.png" /></p>
<p>对于负数的算术右移需要注意，它的商是向下取整的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926648-b4f62fa0-878b-406f-aa81-5c49745fcc95.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926648-b4f62fa0-878b-406f-aa81-5c49745fcc95.png" /></p>
<p>因此需要在右移前需要添加一个偏置量，右移 k 位，偏置量为 (1&lt;&lt;k) - 1</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926738-1b825714-172f-49d6-acba-20177e2716b9.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926738-1b825714-172f-49d6-acba-20177e2716b9.png" /></p>
<p>对补码右移除法的总结</p>
<p>对于这种替换除法指令的方法不能推广到任意常数，只能是 2 的幂</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926863-92e9edfc-6a33-4a9e-bea2-0f4c16f086a4.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926863-92e9edfc-6a33-4a9e-bea2-0f4c16f086a4.png" /></p>
<h2 id="浮点数"><a class="anchor" href="#浮点数">#</a> 浮点数</h2>
<h3 id="tfff关于浮点数的表示"><a class="anchor" href="#tfff关于浮点数的表示">#</a> TFFF 关于浮点数的表示</h3>
<p>s：符号位</p>
<p>exp： 与阶码 E 有关</p>
<p>frac：与尾数 M 有关</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926952-085d0851-e224-45af-8ef0-71fda4925058.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336926952-085d0851-e224-45af-8ef0-71fda4925058.png" /></p>
<p><strong>浮点数的三种类型</strong></p>
<p>阶码的值决定了这个数属于那种类型</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927041-3903c9eb-5d54-4f30-86a3-281018adc808.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927041-3903c9eb-5d54-4f30-86a3-281018adc808.png" /></p>
<p>规格化的值：阶码不全为 0 或 1</p>
<p>非规格化的值：阶码全为 0</p>
<p>特殊值：阶码全为 1，特殊值又分为两类，当 f 全为 0 时表示无穷，分为正无穷和负无穷，当 f 不为 0 时，表示 NaN</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927136-73d9b1ea-a874-4cf1-8788-222780c58320.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927136-73d9b1ea-a874-4cf1-8788-222780c58320.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927232-191bfa24-9550-4d7d-a325-44a47d3e45ed.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927232-191bfa24-9550-4d7d-a325-44a47d3e45ed.png" /></p>
<p><strong>规格化的值的阶码字段</strong></p>
<p>阶码等于 e 减去一个偏置量，bias = 2^k - 1 k 为阶码位长度</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927327-dcb7269e-01c8-400e-bfd0-ab96d148a0a0.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927327-dcb7269e-01c8-400e-bfd0-ab96d148a0a0.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927418-1faf301a-b3c2-4449-8301-7930a183b8b5.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927418-1faf301a-b3c2-4449-8301-7930a183b8b5.png" /></p>
<p><strong>规格化的值的尾数字段</strong></p>
<p>因为有这种表示方式，总会有 1，所以 TEEE 规定 f 舍弃开头的一</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927493-2b3fbf89-b0c8-466d-86d5-f9334b429c07.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927493-2b3fbf89-b0c8-466d-86d5-f9334b429c07.png" /></p>
<p><strong>非规格化的值表示 0</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927586-d950807f-5382-4576-a7db-756134e69940.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927586-d950807f-5382-4576-a7db-756134e69940.png" /></p>
<p><strong>非规格化的值表示接近 0 的数</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927670-8d19bd06-5335-4430-9e30-3ba2b263c7dd.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927670-8d19bd06-5335-4430-9e30-3ba2b263c7dd.png" /></p>
<h3 id="将整型转化位浮点数"><a class="anchor" href="#将整型转化位浮点数">#</a> 将整型转化位浮点数</h3>
<p>上为 12345 的补码表示，下为 12345.0 的浮点数表示，它们之间有相匹配的字段，这是怎样形成的呢</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927763-e0450322-b9f1-4d09-a9be-85c34b4c66a3.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927763-e0450322-b9f1-4d09-a9be-85c34b4c66a3.png" /></p>
<p>因为 12345 补码表示只有低 14 为有效，所以我们可以只看低 14 位，再表示成如图所示的方式表示这 14 位，根据 TEEE 的规定，舍弃第一个 1，因为 float 的小数字段有 23 位，所以在右端不上 10 个 0</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927846-2ae1f24c-a526-48a6-8dba-f3ad4507923b.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927846-2ae1f24c-a526-48a6-8dba-f3ad4507923b.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927938-a309e42c-6ba9-403f-995f-d783cde81436.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336927938-a309e42c-6ba9-403f-995f-d783cde81436.png" /></p>
<p>根据规格化的值的浮点数表示得阶码为 13</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928024-f4da50ff-cdaf-464f-88f2-08f224eab26f.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928024-f4da50ff-cdaf-464f-88f2-08f224eab26f.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928114-75998d3a-c8e6-40be-8e2b-47af04a44353.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928114-75998d3a-c8e6-40be-8e2b-47af04a44353.png" /></p>
<p>再加上符号位</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928198-a233e2c5-38a0-4ef5-88d2-c082b174db0e.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928198-a233e2c5-38a0-4ef5-88d2-c082b174db0e.png" /></p>
<h3 id="舍入"><a class="anchor" href="#舍入">#</a> 舍入</h3>
<p>TFFF 规定的浮点数舍入规则时 “向偶数舍入” 也称作 “向接近的数舍入”</p>
<p>为什么要采用 “向偶数舍入” 呢因为总是采用 “向上舍入” 会导致结果的平均值比真实值略高，总是采用 “向下舍入” 会导致结果的平均值比真实值略低</p>
<p><strong>对于处于两个可能值之间的数才考虑向偶数舍入</strong>，其规则是时<strong>最低有效位的值为偶数</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928284-868b248f-843a-4767-b889-215c78cdb822.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928284-868b248f-843a-4767-b889-215c78cdb822.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928378-3256f91c-eebf-4f4f-a754-f20d9cdaa0d1.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928378-3256f91c-eebf-4f4f-a754-f20d9cdaa0d1.png" /></p>
<h3 id="浮点数一些运算上的缺陷"><a class="anchor" href="#浮点数一些运算上的缺陷">#</a> 浮点数一些运算上的缺陷</h3>
<p>由于舍入而不具有结合性</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928463-3fa8bcd0-eaf7-4fd9-83a9-22789dad70a7.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928463-3fa8bcd0-eaf7-4fd9-83a9-22789dad70a7.png" /></p>
<p>乘法不具备分配性</p>
<p>（6）中 1e20 * 1e20 = 正无穷 ，两个正无穷相减结果为 NaN</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928554-94c9d32a-9e94-4ad0-9cc8-77823e396b83.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928554-94c9d32a-9e94-4ad0-9cc8-77823e396b83.png" /></p>
<h3 id="int-float-double"><a class="anchor" href="#int-float-double">#</a> int&lt;--&gt;float&lt;--&gt;double</h3>
<p>1. 由于 float 的小数字段只有 23 位，所以 int 转为 float 可能会被舍入</p>
<p>2.double 具有更大的范围和精确度，所以这个转化无影响</p>
<p>3.double 范围大，转为 float 可能发生溢出</p>
<p>4. 可能溢出，也可能向 0 舍入</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928651-28416c7c-711b-4f1e-91d9-b29c6e4072e1.png" alt="https://cdn.nlark.com/yuque/0/2022/png/23204417/1647336928651-28416c7c-711b-4f1e-91d9-b29c6e4072e1.png" /></p>
