<h1 id="寄存器内存访问"><a class="anchor" href="#寄存器内存访问">#</a> 寄存器（内存访问）</h1>
<h3 id="内存中字的储存"><a class="anchor" href="#内存中字的储存">#</a> 内存中字的储存</h3>
<p>8086CPU 的寄存器是 16 位，而一个内存单元只能存储一个字节即 8 位，所以需要用两个内存单元储存一个字型数据</p>
<p>** 字单元：存放一个字型数据的内存单元，有两个地址连续的内存单元组成。** 高地址内存单元储存字型数据中的高位字节，低地址内存单元储存字型数据中低位字节</p>
<h3 id="ds和address"><a class="anchor" href="#ds和address">#</a> DS 和 [address]</h3>
<p>cs 和 ip 分别储存指令的段地址和偏移地址，数据和指令都是一样的，都是用二进制表示，只是不同的寄存器访问则有不同的意义，所以访问数据的段地址就存储在<strong> DS 寄存器</strong>中</p>
<p>但这有所不同，没有储存偏移地址的寄存器</p>
<p>我们想使用数据时，偏移地址用 **[address]** 表示，如 mov ax,[10] cpu 会将 1000：0010 处字单元中的数据给 ax 寄存器，也就是说每次使用 [address] 时，cpu 会取 ds 寄存器中的数据作为段地址</p>
<p>CPU 不支持将数据直接送入段寄存器的操作</p>
<p>所以一般是把数据送入 ax 或 bx 寄存器，再将 ax 或 bx 中的数据送入 ds</p>
<h3 id="字的传送"><a class="anchor" href="#字的传送">#</a> 字的传送</h3>
<p>当传送字型数据时，使用的地址 N 是字型数据的起始地址</p>
<h3 id="栈"><a class="anchor" href="#栈">#</a> 栈</h3>
<p>特点：后进先出</p>
<p>基本操作：入栈（push），出栈（pop）</p>
<h3 id="cpu提供的栈机制"><a class="anchor" href="#cpu提供的栈机制">#</a> CPU 提供的栈机制</h3>
<p>CPU 如何知道栈顶在哪儿呢</p>
<p>操作数据必然需要地址，所以就有 SS 寄存器储存栈顶段地址，SP 寄存器储存栈顶偏移地址</p>
<p>任何时候<strong> SS:SP 指向栈顶元素</strong></p>
<p>执行 push ax 过程</p>
<p>（1）sp = sp - 2 以当前栈顶元素前的单元位新的栈顶</p>
<p>（2）将 ax 中的数据送入 SS：SP 指向的内存单元处，此时 SS:SP 指向新的栈顶</p>
<p>执行 pop ax 过程</p>
<p>（1）将 SS:SP 指向的内存单元中的数据送入 ax 中</p>
<p>（2）SP = SP + 2</p>
<p>8086CPU 只能记录栈顶，栈空间大小需要我们自己管理</p>
<p>push [idata] 理解为将 ds:[idata] 处的数据送入新栈顶</p>
<p>pop [idata] 理解为将栈顶的数据送入 ds:[idata] 处，同时栈顶指针下移</p>
